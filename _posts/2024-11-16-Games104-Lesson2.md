---
title: "Lesson2"
date: 2024-11-16
layout: default
---

# 游戏世界构建及其组织方式

## 1. 游戏世界的构成

### 动态游戏物体 (Dynamic Game Objects)

动态物体是会随着时间和玩家的操作发生变化的物体，通常包括可移动、可交互的元素。

- **坦克**

  - 坦克是可移动的物体，通常有位置、速度、方向、生命值等属性。它可能会与其他物体发生碰撞、攻击敌人等。
  - 需要处理：位置更新、碰撞检测、动画切换（移动、攻击、死亡等）。

- **士兵**
  - 与坦克类似，士兵也是动态物体。士兵有移动、攻击、死亡等状态，可能需要切换动画和进行状态管理。
  - 需要处理：行走、跑步、跳跃、攻击、死亡等行为。

#### 补充说明：

- **动态物体的状态**：动态物体通常需要处理状态机和行为逻辑，决定每个物体在不同状态下的行为。
- **物理计算**：动态物体的物理行为（如重力、碰撞、力学）常常需要专门的物理引擎来处理。

---

### 静态游戏物体 (Static Game Objects)

静态物体通常不发生位置变化，主要用于构建游戏世界的环境。

- **房子**

  - 房子一般为场景中的不动物体，可能会有细节的损坏或状态变化（例如，遭受攻击后的破坏效果）。
  - 需要处理：碰撞体积、物理特性（例如抗摧毁力、耐久度）等。

- **箱子**
  - 箱子是环境中可能与玩家交互的静态物体。例如，玩家可能与箱子互动推动、打开或摧毁。
  - 需要处理：是否可以破坏、是否可互动等。

#### 补充说明：

- **静态物体的管理**：静态物体通常不会更新位置，但它们可能需要处理状态变化（如破损、损坏、被推翻等）。
- **优化**：静态物体的碰撞检测可以通过空间划分（如四叉树、网格化碰撞等）来优化，减少性能开销。

---

### 环境 (Environment)

环境物体和元素通常不直接参与游戏的互动，但它们对游戏的气氛、视觉效果和游戏规则有很大影响。

- **天空**

  - 天空通常是背景元素，但在一些游戏中可能随着时间流逝变化（如白天到夜晚的过渡）。
  - 需要处理：光照、天空纹理、天气效果等。

- **植被**

  - 植被（如树木、草地等）可能作为环境元素存在，也可能与动态物体发生互动（例如，坦克经过时压倒树木）。
  - 需要处理：物理碰撞、视觉效果、动态变化等。

- **地形**

  - 游戏世界的地形通常作为静态元素存在，但有时也会发生变化（如爆炸形成坑洞、破坏性地形等）。
  - 需要处理：地形碰撞、物理模拟、可破坏地形等。

- **一天中的时间 (Time of the Day)**

  - 游戏中的时间系统通常会影响环境的变化，例如白天、夜晚的光照变化。
  - 需要处理：光照、阴影、天气变化等。

- **系统**
  - **天气系统**：可能包括雨、雪、雾等天气效果，直接影响玩家的视野和操作。
  - **光照系统**：光照和阴影的变化会直接影响游戏的氛围和视觉表现。
  - 需要处理：天气变化、时间变化对环境的影响、光照的计算等。

#### 补充说明：

- **环境交互性**：虽然环境物体本身不直接与玩家互动，但它们的状态变化（如光照、天气、地形变化等）会间接影响游戏玩法。

---

### 其他游戏物体 (Other Game Objects)

这些物体虽然在游戏中不一定会显示出来，但它们的存在和交互对游戏进程有重要影响。

- **空气墙**

  - 空气墙是不可见的物体，通常用于限制玩家的移动范围。当玩家碰到空气墙时，无法穿越或离开指定区域。
  - 需要处理：与玩家或动态物体的碰撞、区域限制等。

- **夺旗点 (Capture Point)**

  - 夺旗点是玩家可以占领的关键区域，通常用于控制和影响游戏进程。
  - 需要处理：玩家占领、状态变更（占领、失守）、互动等。

- **触发区域 (Trigger Area)**
  - 触发区域是游戏世界中看不见的区域，用于触发特定事件或条件。例如，玩家进入某个区域时触发敌人出现、剧情推进等。
  - 需要处理：区域检测、事件激活、条件触发等。

#### 补充说明：

- **虚拟物体**：空气墙、夺旗点和触发区域是典型的虚拟物体，通常由某种事件系统或脚本来管理它们的交互与触发逻辑。

---

## 2. 创建 GameObject（以无人机为例）

### 物体属性和行为

在游戏设计中，我们通过定义物体的属性和行为来描述每个对象的功能。

- **属性**（Property）：

  - **形状**（Shape）：物体的外观、结构。
  - **位置**（Position）：物体在世界中的位置。
  - **电池容量**（Battery Capacity）：无人机的电池能量，影响持续飞行时间。

- **行为**（Behaviour）：
  - **移动**（Move）：物体的移动方式。
  - **巡逻**（Scout）：无人机的特定行为，如自动巡航或搜索目标。

这些属性和行为的组合决定了物体在游戏中的功能和表现。

---

## 3. 游戏引擎早期处理方式

在早期的游戏引擎中，通常采用**面向对象编程**的方式，通过继承关系来组织和管理物体。这种方法通过父类和子类之间的关系来定义物体的功能。

- **无人机 → 攻击无人机**：例如，攻击无人机可以是无人机的子类，继承了无人机的基本属性和行为，同时添加攻击行为。

这种方式简单直观，但随着游戏世界的复杂性增加，这种**单一继承**关系变得越来越难以管理。例如：

- **水陆两栖坦克**：一个物体可能同时具有坦克和船的特性，传统的继承关系（坦克 → 水陆两栖坦克）无法清晰表达这一点。

这种问题促使了**组件化思想**的诞生。

---

## 4. 组件化思想的诞生

**组件化**（Component-based architecture）思想的核心在于，将一个物体的功能拆分成多个独立的模块（或组件），而不是通过继承关系来定义。每个组件负责处理物体的一部分功能，这样不仅可以更灵活地组合不同的功能，还可以更容易地扩展和维护。

### 组件化设计

为了实现组件化，我们通常会设计一个基类 `ComponentBase`，所有的具体组件都继承自它。每个组件都有独立的功能和生命周期，管理和调用组件变得更加模块化。

- **ComponentBase 类**：

  - 组件的基类通常会包含一个虚函数 `Tick()`，该函数用于更新组件的状态。在每一帧（或每个游戏循环）中，游戏引擎会调用所有组件的 `Tick()` 函数，以便进行状态更新。
  - 组件通常会以容器（如 `vector<ComponentBase*>`）的形式保存在游戏对象中，每个物体可以拥有多个组件，而这些组件则可以在物体的生命周期内被创建、销毁或更新。

- **游戏对象的组件管理**：

  - 在组件化设计中，物体的行为不再通过继承树来定义，而是通过组合不同的组件来实现。比如，**无人机**可以由以下组件组合而成：
    - **Transform**：控制物体的位置、旋转、缩放。
    - **Model**：表示物体的模型和渲染信息。
    - **Motor**：控制无人机的动力系统。
    - **Physics**：处理物理行为，如重力、碰撞等。
    - **AI**：实现自动控制逻辑（如巡逻、避障）。

- **类似于 Unity 的组件模式**：
  - 在 Unity 等现代游戏引擎中，组件化设计被广泛应用。每个游戏对象都有一个或多个组件，组件负责处理物体的不同行为。通过这种方式，游戏开发者可以更加灵活地组合不同的功能，而不需要为每个新功能创建一个新的子类。

### 示例：无人机的组件化设计

以**无人机**为例，传统的面向对象设计可能会通过继承来定义无人机的各种行为。但如果采用组件化设计，我们将无人机的功能拆分成多个独立的组件：

- **Transform**：控制无人机的位置和旋转。
- **Model**：表示无人机的外观和渲染。
- **Motor**：控制无人机的动力和速度。
- **Animation**：定义无人机的动画效果（如飞行、转弯等）。
- **Physics**：处理无人机的物理行为，如重力和碰撞。
- **AI**：实现无人机的智能行为，如自动巡逻或避障。

每个组件都有独立的职责，通过组合这些组件，无人机就能够完成复杂的任务。

### 组件化的优势

- **解耦和灵活性**：每个组件只关注一个特定的功能，使得物体的功能更加模块化，便于修改和扩展。
- **复用性**：组件可以在不同的物体间共享和重用，提高了开发效率。
- **易于维护**：更易于进行独立的调试和优化，因为每个组件都可以单独测试和修改。

通过将物体的功能拆分为多个独立的组件，游戏开发者可以更加灵活地控制物体的行为，并可以方便地替换或扩展现有的组件。比如，在一个射击游戏中，可以通过替换**枪械**组件，改变武器的射击行为，而不需要重新设计整个角色。

---

## 5. 游戏引擎架构核心理念

### 直观性与易用性

- 游戏引擎的架构设计应该尽量符合开发者的直觉，使得使用引擎的过程更加自然和高效。引擎的各项功能和 API 应易于理解和使用，从而降低学习曲线，提升开发者的生产力。

### 游戏世界的动态性

- 游戏世界中的物体是动态的，并非静止不动。每个物体在游戏世界中的状态需要在每一帧更新。这一更新过程通常被称为**Tick**。
  - 类比于**普朗克时间**，每一帧的更新代表了系统的最小时间步长。通过不断地对物体进行状态更新和渲染，游戏得以流畅运行。

### 系统化的`Tick()`流程

- 在游戏引擎中，`Tick()`是一个核心概念，但引擎的设计是按**系统**进行 `Tick()`，而不是按物体或组件进行 `Tick()`。
  - 每个系统专注于自己负责的功能，如物理系统、渲染系统、AI 系统等。每个系统都会在每一帧中进行独立的更新和处理。这种设计使得引擎的处理更加模块化，并且能够提高效率。

### 流水线式的处理架构

- 为了提高性能，引擎的设计通常采用**流水线**的思路。
  - 每个系统按固定的顺序处理各自的任务。例如，物理系统可能先于渲染系统执行，以保证物体位置的更新是准确的。在这个流水线中，每个系统独立工作，并且能够并行处理，减少冗余和提高处理速度。

### 提高效率与优化

- 按系统进行 `Tick()` 而非按物体组件进行 `Tick()` 的设计，带来显著的性能优化。通过这种方式，开发者可以避免在每一帧中为每个物体逐一调用组件的更新方法，进而减少不必要的计算开销。
  - 例如，物理系统可能只关心运动相关的组件（如速度、位置），而渲染系统则只关心需要显示的物体信息（如模型、材质）。这种按职责分离的设计使得引擎在处理时更加高效和集中。

---

## 6. 游戏世界的交互

### 游戏玩法示例：坦克攻击与命中检测

在游戏中，当坦克发射炮弹时，如何判断炮弹是否击中目标坦克？这个过程涉及到碰撞检测和响应。

- **炮弹命中逻辑**：  
  当炮弹飞行到某个位置时，游戏引擎需要检测炮弹是否与其他物体（例如敌方坦克）发生碰撞。碰撞检测的基本步骤如下：

  - **碰撞检测**：检查炮弹与敌方坦克是否相交，通常是通过几何算法（如矩形、圆形或射线碰撞检测）来判断。
  - **触发事件**：当炮弹与敌方坦克发生碰撞时，触发相应的事件（例如扣除坦克的生命值）。

- **常见的碰撞检测方法**：
  - **AABB（轴对齐包围盒）**：适用于矩形或方形物体，检测是否发生重叠。
  - **圆形检测**：适用于子弹或其他圆形物体，检测炮弹的中心是否与敌坦克的范围重叠。
  - **射线检测**：常用于判断炮弹沿直线轨迹是否与物体发生交集，适合射击类游戏。
  - **多边形碰撞**：适用于不规则形状的物体，通常需要更复杂的计算。

### 事件派发机制

事件派发机制是游戏开发中常见的设计模式，旨在解耦物体之间的交互。通过事件的发布和监听，物体之间不直接依赖于彼此，而是通过事件系统来传递信息。

#### 如何通过事件派发机制解耦交互？

**事件总线（Event Bus）**：

- 事件总线是一个中心化的消息传递系统，允许多个对象通过注册和触发事件来进行通信。通过事件总线，物体之间不需要知道彼此的具体实现，而只需要关心事件的触发和响应。

**事件监听器（Event Listener）**：

- 游戏对象通常会注册特定事件的监听器。当事件被触发时，所有注册了该事件的对象都会收到通知，并做出相应的反应。

**事件解耦的优点**：

- **模块化**：通过事件机制，物体之间的交互被解耦，代码更加模块化，容易扩展和维护。
- **灵活性**：可以随时添加新的事件监听器或触发器，而不会影响现有系统。
- **响应性**：物体能够快速响应游戏中发生的各种事件（例如“被击中”或“触发攻击”）。

#### 示例：通过事件派发实现炮弹击中坦克

下面是一个简单的示例，展示如何使用事件总线解耦炮弹和坦克之间的交互。

```python
# 事件总线
class EventBus:
    def __init__(self):
        self.listeners = {}

    def register(self, event_type, listener):
        if event_type not in self.listeners:
            self.listeners[event_type] = []
        self.listeners[event_type].append(listener)

    def dispatch(self, event_type, data):
        if event_type in self.listeners:
            for listener in self.listeners[event_type]:
                listener(data)

# 炮弹类
class Bullet:
    def __init__(self, event_bus):
        self.event_bus = event_bus

    def hit_target(self, target):
        # 触发“坦克被击中”事件
        self.event_bus.dispatch('tank_hit', target)

# 坦克类
class Tank:
    def __init__(self, event_bus):
        self.hp = 100
        event_bus.register('tank_hit', self.on_hit)

    def on_hit(self, target):
        if target == self:
            self.hp -= 10
            print(f"坦克被击中，当前血量：{self.hp}")

# 使用事件总线来解耦
event_bus = EventBus()
tank = Tank(event_bus)
bullet = Bullet(event_bus)

# 模拟炮弹击中坦克
bullet.hit_target(tank)
```

## 7. 场景中如何管理 GameObject

在游戏场景中，管理大量的 `GameObject` 需要高效的空间管理策略。以下是几种常见的管理方法：

### **空间管理策略**

- 使用 **UID**（唯一标识符）和 **位置** 来管理物体。每个物体都拥有唯一的 ID 和空间坐标，方便进行快速查找和操作。
- 炮弹爆炸时需要检测场景中所有物体，并判断它们是否在爆炸范围内。为此，优化场景管理非常关键。

### **管理方法**

#### **网格划分**

- **方法**：将世界划分为均匀的格子，每个物体的位置根据格子进行管理。当需要判断炮弹爆炸的影响范围时，只需要检查炮弹所在的格子和其周围的格子即可。

- **优点**：简单易实现，适用于大多数场景，特别是在物体分布较均匀的情况下。

#### **四叉树 (QuadTree)**

- **方法**：将世界空间分割为四个区域，递归地对子区域进行划分，形成树形结构。每个物体会根据其坐标被分配到适当的子区域。

- **优点**：四叉树适用于动态物体分布广泛的场景，可以减少查找和碰撞检测的计算量。

#### **包围体层次 (BVH)**

- **方法**：使用 **包围体层次**（Bounding Volume Hierarchy，简称 BVH）来组织场景中的物体。每个物体都有一个包围体，而这些包围体会组成一个树形层次结构。通过遍历包围体层次，可以快速地排除不需要计算的物体，减少空间查找的时间。

- **优点**：适用于复杂的场景和多物体碰撞检测，现代游戏引擎（如 Unity、Unreal）通常使用 BVH 来进行空间裁剪和碰撞检测。

### **现代引擎的实现**

现代游戏引擎通常采用 **BVH** 或类似的优化结构（例如：**KD-Tree**）来实现空间裁剪。这些技术通过层次化的结构减少不必要的计算，提升渲染和碰撞检测的效率。

## 8. 商业游戏引擎解决的问题

### 车与人之间的联动

在许多游戏中，车和人（或角色）之间有密切的互动。游戏引擎需要处理好它们之间的顺序和事件通信。

- **组件顺序问题**：车的组件通常需要先于人的组件进行 `Tick()`，以确保车和人的状态同步。
- **事件通信问题**：当两个组件同时派发事件时，可能会发生冲突或导致不一致的状态。解决这个问题需要合理的事件调度机制，比如确保事件按正确的顺序派发，或使用优先级机制。

### 引擎的可重现性

商业游戏引擎要求在相同的输入下，能够得到一致的输出，这是为了确保游戏体验的稳定性和可调试性。

- **回放系统**：通过记录玩家的输入，游戏引擎能够重放相同的事件序列。这不仅有助于调试，还能让玩家查看自己的游戏录像。

  具体来说，回放系统通常会将玩家的输入（例如控制动作）记录下来，然后在后续的时间里，使用这些输入重新运行游戏模拟，从而重现游戏过程。

### 多线程问题

为了提升性能，现代游戏引擎往往采用多线程处理。然而，这也带来了线程安全问题，特别是在事件处理和数据共享时。

- **“邮局”模型**：引入“邮局”概念，将事件消息放入“邮局”，由邮局统一调度和派发。这样可以避免直接在多线程中相互调用，减少线程同步问题。

  - 邮局的作用是缓解事件的竞争条件，并保证事件处理的顺序性。在这种模型下，游戏中的多个线程可以独立工作，事件消息由邮局来统一管理和派发，避免直接操作共享资源。

### 预测与后期处理

在许多情况下，游戏引擎需要处理时序性问题，特别是涉及到多个组件间的互动时。

- **`Predict()` 函数**：该函数通常用于预测游戏世界的状态。例如，在物理引擎中，可以预测下一帧的位置和速度等，提前计算并准备好数据。

- **`PostTick()` 函数**：用于在 `Tick()` 执行完之后处理额外的逻辑。例如，根据新的物理状态来更新动画，或者根据玩家的输入来调整角色的行为。

- **循环依赖问题**：在游戏中，某些组件可能会存在互相依赖的情况。例如：

  - 位置改变可能会影响动画的播放。
  - 动画变化可能会影响物理行为。
  - 物理行为的改变又会反过来影响动画状态。

  这种 **循环依赖** 问题需要通过精确的时序管理来解决。通常，游戏引擎会采用分离的更新步骤，例如先更新物理组件，再更新动画组件，确保每一部分的状态更新是独立且有序的。

## 9. Tick 时间过长的处理方法

### **解决方法**：

当游戏的 `Tick` 时间过长时，可能导致物理模拟和游戏逻辑的延迟，从而影响游戏体验。为了解决这个问题，可以采取以下方法：

1. **传入步长，进行位移补偿**：
   - 通过增加时间步长的传递，计算出实际的位移补偿。这能够确保即使每帧的 `Tick` 时间较长，游戏逻辑仍然可以按预期运行。
2. **Tick 多帧，处理跨帧逻辑**：
   - 如果一次 `Tick` 时间过长，处理不完所有的更新逻辑，可以分成多个 `Tick` 来执行。这样可以分摊计算量，避免大规模的延迟和跳帧。

### **优化引擎设计**：

为了提高处理效率，可以采取以下措施：

- **物体分帧处理**：将游戏中的物体和场景分成不同的更新组，分帧更新它们的状态。这样可以根据物体的复杂程度合理安排更新频率，避免过度计算。
- **增加更多的帧来处理复杂的逻辑**：通过在逻辑上增加更多的更新帧来避免因每帧计算量过大而引起的延迟问题。

---

## 10. 逻辑线程与渲染线程同步

### **渲染与逻辑线程的同步**：

在游戏中，渲染线程负责绘制画面，而逻辑线程负责更新游戏状态。正确的线程同步非常关键，否则会出现以下问题：

- **不当的同步**可能导致：

  - 逻辑线程运行一帧后，延迟一帧才更新渲染。
  - 渲染线程跑一帧后，也需要延迟一帧才能更新显示。

  这种延迟会影响游戏的流畅度和响应性。因此，正确的同步策略非常重要，通常采用双缓冲、锁步同步等技术来保证两个线程的协调工作。

---

## 11. 动态游戏对象的空间划分

### **动态游戏对象的处理**：

在大型游戏中，尤其是射击类游戏（例如《战地》系列），场景中通常包含大量的动态对象。每一帧都需要更新这些物体的位置和状态。如果不优化，可能会导致性能问题。

- **选择轻量更新方式**：为了避免对每个物体进行过度计算，可以使用空间划分方法来优化对象更新。常见的技术包括：

  - **八叉树**：将三维空间划分为多个小区域，每个区域包含一定数量的对象，只对这些区域内的对象进行更新。
  - **BVH（包围体层次结构）**：通过树形结构对物体进行组织，快速查找和碰撞检测。

  这种空间划分方法有助于减少无效计算，提高性能，尤其适用于动态物体较多的场景。

---

## 12. 组件模式的缺点与改进

### **组件模式的缺点**：

组件化设计（例如将物体的不同属性如位置、速度、生命值等拆分为独立的组件）虽然提升了游戏开发的灵活性，但在性能上可能存在问题：

- **性能问题**：直接访问组件时，性能可能不如将多个组件合并为一个类。特别是在大量实体和频繁查询时，组件间的通信开销可能比较大。

### **解决方案：ECS（实体组件系统）**：

为了优化组件化设计的性能问题，采用 **ECS** 设计模式将同类组件放在一起进行处理，从而减少频繁的查询操作。

- **ECS 的优势**：
  - 通过将相同类型的组件放到一起，提高了数据局部性，减少了内存访问的开销。
  - 通过批量处理相同类型的组件，提高了执行效率。

### **频繁的 Query 操作**：

组件之间需要通过查询操作来进行通信，过多的查询会增加系统的开销。优化方式包括：

- 尽量减少跨组件的查询操作。
- 合理组织组件的存储结构，减少不必要的查询操作。

---

## 13. 事件机制的调试

### **调试事件机制的工具**：

在游戏引擎中，事件机制用于不同系统间的通信，调试事件机制时，**日志（Log）** 是最常用的工具之一。通过记录事件的触发和传递过程，开发者可以快速定位问题。

- **日志记录**：在事件触发时，记录相关信息（如事件类型、触发者、目标对象等），帮助调试和优化。

---

## 14. 物理与动画的相互影响

### **物理与动画的交互**：

在现代游戏中，物理模拟和动画系统常常需要相互配合，尤其是在角色的动作和碰撞处理方面。

- **布娃娃（Ragdoll）动画**：布娃娃动画通常用于角色死亡时的物理反应，但这种动画有时会缺乏打击感。为了解决这个问题，可以结合物理模拟和插值方法来增强动画的表现力。
  - **插值方法**：通过在物理模拟和动画之间进行插值，平滑过渡两者的状态，既保留了物理碰撞的真实感，又不失流畅的动画效果。

这种结合方式能够提升游戏中的打击感和互动性，使得角色的行为更具真实感和表现力。

---

[back](https://fenglimg.github.io/skills-github-pages/2024/11/03/Games104-Notes.html)
