---
title: "Lesson1"
date: 2024-11-03
layout: default
---

# 游戏引擎架构分层

游戏引擎架构通常采用分层设计，以便于开发、管理和扩展。以下是常见的游戏引擎分层结构说明，每一层都承担着不同的责任，确保引擎的高效和灵活性。
接下来以一个 3d 平台游戏为例介绍各个分层的功能。

---

## 1. 工具层 (Tool Layer)

**情景**：
我们正在开发一个平台游戏，我们需要使用游戏素材，那我们应该如何导入呢？游戏中的场景需要设计得既富有挑战性又具备视觉吸引力。我们如何安排关卡中的各个元素，比如平台的位置、障碍物的布局？

**功能**：  
工具层主要是为开发者提供可视化的编辑界面和辅助工具，帮助他们在开发过程中进行资源的管理、场景的编辑、代码调试等工作。这个层次包括：

- **场景编辑器**：开发者用来创建和编辑游戏场景的可视化工具。
- **资源管理器**：用于组织和管理游戏中的所有资源（如模型、纹理、音效等）。
- **脚本调试器和日志系统**：提供实时调试和日志查看，帮助开发者发现问题。
- **动画编辑器、UI 编辑器**：用于创建和调试游戏内动画及界面元素。

---

## 2. 功能层 (Function Layer)

**情景**：
我们已经设计好了游戏的世界，但游戏中的角色如何与环境互动，才能让游戏机制更加生动呢？如何让角色的动作既符合物理规律又不失流畅性？如果我们需要实现复杂的物理模拟、精美的动画效果，我们会依赖哪些系统来支撑这些功能？

**功能**：  
功能层包含了游戏引擎的核心功能模块，负责实现游戏的运行机制。这一层主要包括：

- **渲染系统**：负责游戏中的图形渲染，包括 2D/3D 绘制、光照、阴影、特效等。
- **物理引擎**：模拟真实世界的物理现象，如碰撞检测、重力、刚体动力学等。
- **动画系统**：处理游戏中的角色和物体动画，包括骨骼动画、面部表情动画等。
- **脚本系统**：通过脚本语言（如 Lua、Python 等）编写游戏逻辑，实现游戏行为控制。
- **状态机**：用于管理游戏对象的不同状态及其状态之间的转变（例如，角色从“走”状态转为“跳跃”状态）。

---

## 3. 资源层 (Resource Layer)

**情景**：
游戏中的资源越来越多，但如果加载时间太长或游戏运行时资源频繁卡顿，玩家的体验会受到影响。你如何管理和优化游戏中的资源，确保它们能够高效加载、流畅运行？如何避免内存泄漏或资源浪费？

**功能**：  
资源层负责管理和加载游戏的各种资源，它对游戏运行时性能至关重要。包括：

- **资源加载管理**：负责从磁盘或网络加载模型、纹理、音频、动画等资源。
- **内存管理**：高效地管理资源在内存中的存储和卸载，避免内存泄漏或过度消耗。
- **资源压缩与优化**：在游戏中使用的资源通常需要进行压缩或格式转换，以减少内存占用和提高加载速度。
- **资源格式支持**：支持多种文件格式（如.obj、.fbx、.png 等），确保资源能够在引擎中顺利使用。

---

## 4. 核心层 (Core Layer)

**情景**：
你开发的游戏需要支持复杂的数学计算，尤其是在三维空间中的位置、旋转和速度等计算。你是否考虑过底层数学运算如何影响游戏的性能？另外，如何在多核处理器上高效地并行计算，避免性能瓶颈？

**功能**：  
核心层提供了游戏引擎的基础设施，负责处理各种底层的操作，包括：

- **容器管理**：管理各种数据结构（如队列、栈、数组等）和对象池，优化内存使用。
- **垃圾回收**：管理内存中的对象生命周期，避免内存泄漏和不必要的内存分配。
- **数学库**：提供向量、矩阵、旋转、变换等数学运算，支撑图形学和物理模拟。
- **线程池与并发**：管理引擎中的多线程任务，优化多核 CPU 的性能，避免线程竞争和死锁。

---

## 5. 平台层 (Platform Layer)

**情景**：
你的游戏将发布到多个平台，比如 Windows、macOS 和移动设备。你如何确保游戏在这些平台上的表现一致，且能够顺利运行？如何处理不同平台上的输入设备差异，例如触摸屏、鼠标或手柄？

**功能**：  
平台层负责引擎与具体平台的交互，包括硬件、操作系统、输入设备等。具体内容有：

- **平台抽象**：为不同操作系统（如 Windows、macOS、Linux）提供统一接口，确保引擎能在多个平台上运行。
- **输入管理**：处理用户输入，包括鼠标、键盘、手柄、触摸屏等设备。
- **文件系统**：为游戏提供平台无关的文件操作接口。
- **网络支持**：处理网络通信，支持多人游戏和网络功能。

---

## 6. 第三方中间件集成 (Third-Party Middleware Integration)

**情景**：
你的游戏需要更复杂的物理模拟，或者更高质量的音效效果，但你并不打算从零开始编写这些系统。你会选择使用第三方中间件吗？如果使用，如何集成这些库来提升游戏的表现和效果？

**功能**：  
这一层是为了增强引擎的功能，集成各种第三方中间件和库。例如：

- **音频中间件**（如 FMOD、Wwise）：提供音效处理、3D 音频定位等高级音频功能。
- **AI 中间件**（如 Recast、NavMesh）：用于实现游戏中的导航网格、路径寻路等 AI 相关功能。
- **物理引擎中间件**（如 Havok、PhysX）：提供更高效、精准的物理模拟。
- **视频渲染库**（如 OpenGL、Vulkan、DirectX）：提供底层图形 API 支持，增强图形渲染性能和效果。

---

# 游戏引擎中的动画处理

在游戏引擎中，动画处理涉及多个环节，包括格式转换、文件关联、资源管理等。以下是这两个方面的详细说明。

---

## 1.格式转换

**情景**：
你正在开发一款 3D 角色扮演游戏，游戏世界的各个场景和角色都需要大量的贴图和模型素材。随着游戏的开发进度，资源的数量越来越庞大，加载时间开始变长，游戏的性能也有所下降。你决定优化资源管理，提升游戏的加载速度和渲染效率。在此过程中，你如何确保从外部获取的图像、模型和音频等资源能够被游戏引擎高效处理，同时不影响最终的画质和游戏体验？

**功能说明**：  
格式转换是指将外部资源文件转换为游戏引擎能够识别并高效加载的格式。例如，将图像文件（如 PNG、JPEG）转换为更适合游戏渲染的格式（如 DDS 格式），或者将模型文件从 FBX 转换为引擎支持的自定义格式。

**关键目标**：

- **优化资源存储**：转换后的文件通常会经过压缩或其他处理，减小存储空间，提升加载效率。
- **统一资源标准**：确保所有资源都符合引擎的格式要求，以便统一处理和管理。

**例子**：

- 将贴图（如 PNG、JPEG 格式）转换为更适合图形处理的 DDS 格式。
- 将 3D 模型（如 FBX 格式）转换为引擎支持的自定义模型格式。

**注意事项**：

- 转换过程中要专注于提取有效的资源数据，忽略生成工具的具体细节。  
  例如，将一个 Word 文档转换为纯文本文件时，文件中的格式信息（如字体、颜色等）通常会被丢弃，只保留文本内容。

---

## 2.关联文件

**情景**：你正在开发一款大型开放世界游戏，游戏中的每个场景都包含多个不同的资源，如 3D 模型、材质、纹理、动画等。随着资源数量的激增，你是否曾感到在管理这些资源之间的复杂关系时困难重重？有没有想过，如果没有一种有效的方式来确保每个资源都能够正确匹配和加载，游戏的表现可能会因此受影响？你如何确保所有模型、材质、纹理和动画等资源能够在加载时顺利协作，而不出现缺失或错乱的情况？在这种资源和场景日益复杂的开发环境中，是否有办法能有效地帮助你管理这些资源的关联性？

你或许已经意识到，通过手动配置每个资源的关系可能不仅容易出错，还会极大增加开发和调试的难度。是否有一种方法可以通过某种结构化的文件，让资源之间的关联更加清晰，并且能够在加载时自动处理这些关系，从而提高效率并避免错误？

**功能说明**：  
关联文件用于在不同资源之间建立联系，以便引擎能够准确地加载并组合它们。例如，场景中的一个 3D 模型可能需要关联特定的纹理、动画和材质等。通过关联文件，可以简化资源的管理，并确保资源在加载时能够正确配合使用。

**关键目标**：

- **简化资源管理**：通过关联文件（如 XML、JSON 等格式），开发者能够清晰地查看和修改资源之间的关系。
- **提高资源加载效率**：引擎可以在加载时通过关联文件快速找到需要的资源，避免不必要的搜索和加载。

**常见格式**：

- **XML**：一种常见的标记语言，适用于描述复杂的资源结构。
- **JSON**：一种轻量级的数据交换格式，易于人类阅读和编写，也方便机器解析和生成。

**UUID 唯一标识符**：

- 为了确保每个资源的唯一性和可追踪性，每个资产（如纹理、模型、动画等）都会分配一个独特的 **UUID**（通用唯一标识符）。这确保了在复杂项目中，资源不会被重复或错误引用。

**例子**：

- 一个包含 3D 模型的 XML 文件可能如下所示：

  ```xml
  <asset>
      <uuid>123e4567-e89b-12d3-a456-426614174000</uuid>
      <type>model</type>
      <path>assets/models/character.obj</path>
      <textures>
          <texture uuid="987e6543-e89b-12d3-a456-426614174111" path="assets/textures/character_diffuse.dds"/>
          <texture uuid="987e6543-e89b-12d3-a456-426614174112" path="assets/textures/character_normal.dds"/>
      </textures>
  </asset>
  ```

# 游戏引擎的 Tick 函数设计

在游戏引擎中，`Tick` 函数通常用于在每一帧更新时进行游戏逻辑处理与渲染。它分为多个子函数或阶段，以确保游戏的流畅执行和高效渲染。

## 情景：

想象一下，你正在玩一款复杂的游戏。你的角色在一个充满敌人和挑战的世界里不断探索，向前奔跑，跳跃，甚至与敌人展开战斗。你按下了控制键，角色迅速做出反应，场景中的一切都在瞬间发生变化：角色移动了，敌人开始追击，障碍物被克服，而环境也在不断变化。你可能会问，是什么让这些变化如此快速且连贯？

游戏世界的“逻辑”是如何随着时间推移不断演变的。角色的位置、敌人的行为、甚至物体的互动，都是通过什么机制进行计算和更新的呢？这种更新是否与游戏的实时状态密切关联？

游戏的画面如何能够在你每次操作后立刻做出反应？游戏中的所有元素如何在屏幕上精准地表现出来，确保玩家看到的每一帧都与游戏的实际状态同步？

## 1.Tick 函数的组成

### `tickLogic` — 处理游戏逻辑更新

- **功能**：`tickLogic` 函数负责更新游戏中的逻辑内容，如角色移动、碰撞检测、AI 行为、物理模拟等。
- **执行时机**：它在每一帧的开始部分执行，确保游戏状态能够根据玩家输入、时间流逝等因素进行更新。
- **重点**：逻辑更新通常不会直接依赖渲染输出，而是根据当前的游戏状态执行相关计算。

### `tickRender` — 负责渲染场景

- **功能**：`tickRender` 函数负责渲染所有游戏场景，包括对象、角色、环境、UI 元素等。它通常会使用由 `tickLogic` 更新后的数据（如角色位置、状态等）来绘制最终图像。
- **执行时机**：`tickRender` 在每一帧的后期执行，确保场景的视觉效果能够展现最新的游戏状态。
- **重点**：渲染过程一般依赖于图形硬件，涉及大量计算，可能会影响帧率。

---

## 2.Tick 函数的更新顺序

### 游戏引擎的更新顺序：为什么先更新逻辑，再渲染画面？

游戏引擎的典型更新顺序是：**首先执行游戏逻辑更新（tickLogic），然后执行渲染（tickRender）**。这样设计的目的是确保渲染出的内容与最新的游戏状态一致。

### 具体原因：

- **保持游戏世界的同步性**：在执行 `tickLogic` 时，所有与角色、环境和物体相关的状态都会更新。通过确保先更新游戏逻辑，再进行渲染，游戏画面才能准确地反映出这些变化。例如，当玩家控制角色移动时，`tickLogic` 会更新角色的位置、速度等信息，确保角色在渲染时出现在正确的位置。
- **避免画面滞后**：如果先进行渲染，后执行逻辑更新，可能会导致画面显示的是上一帧的状态，而不是当前的最新状态。玩家可能看到角色停留在上一个位置，或场景没有及时反应出游戏世界中的变化，这会大大影响游戏的流畅性和沉浸感。

### 举例说明：

假设有一个简单的场景，其中玩家控制一个角色在地图上移动。以下是更新顺序可能带来的不同效果：

#### tickLogic -> tickRender：

1. 玩家按下了移动键，`tickLogic` 会更新角色的位置和状态。
2. 随后，`tickRender` 会使用最新的逻辑数据来绘制画面，角色出现在新的位置，其他与角色相关的变化（如环境交互、敌人追击等）也会同步展示。

#### tickRender -> tickLogic：

1. 如果先执行渲染，玩家按下移动键后，渲染出来的角色位置还是旧的位置。
2. 然后执行 `tickLogic` 更新角色的位置，但渲染画面已经展示了旧的角色位置，造成画面和逻辑之间的不同步。

---

## 3.多线程支持

为了提高性能和响应速度，特别是在复杂场景中，`tickLogic` 和 `tickRender` 可以分配到不同的线程中并行执行。

### 设计目标：

- **分离计算和渲染**：将游戏逻辑和渲染操作分离到独立的线程中，可以让游戏引擎同时进行计算和渲染，从而提高帧率和响应速度。
- **减少瓶颈**：渲染通常是一个耗时的操作，若与游戏逻辑在同一线程中执行，可能会导致性能瓶颈。通过多线程设计，能够在不同核心上并行处理游戏逻辑和渲染任务。

### 关键注意事项：

- **线程同步**：多线程设计需要确保线程间的数据同步，避免数据冲突或错误。例如，`tickRender` 需要访问由 `tickLogic` 更新的状态，若没有适当的同步机制，可能会出现渲染不一致的情况。
- **资源管理**：多线程会增加对资源的竞争，尤其是在渲染和逻辑更新同时发生时。因此，需要仔细管理内存和数据访问。

### 举例说明：

假设游戏中有多个 NPC 和物体需要模拟其行为。如果 `tickLogic` 在一个线程中更新这些 NPC 的位置和状态，而 `tickRender` 在另一个线程中渲染场景，两个线程可以并行工作，从而提高整个引擎的运行效率。

---

# 游戏引擎 RunTime 设计

## 游戏引擎的设计涉及多个层级，每一层都有其特定的功能和责任，下面是对引擎设计各层级的详细说明。

## 1.工具层

工具层为开发者提供了可定制的工作环境，支持多种开发工具和资产处理管线。

### 场景引入：开发者如何在多样的工具选择中找到最合适的工作方式？

假设你是一位游戏开发团队的成员，项目中涉及到不同的任务和不同的技术需求。你需要与设计师、程序员、音效师等不同岗位的同事协作开发一款复杂的游戏。那么，在开发过程中，你是否会遇到以下几个疑问？

- **开发工具该如何选择？** 你是应该继续使用你熟悉的 C++ 来开发底层引擎，还是选择更适合快速开发界面的 Qt、C# 或 WPF 来实现某些功能？
- **如何在多人团队中高效协作？** 如果不同的团队成员需要共同编辑一个关卡或修改某些资产，如何确保数据不冲突，且能够同步更新？
- **如何确保工具和引擎能够无缝协作？** 当你需要将外部设计软件中的模型、纹理或音效导入到游戏引擎中时，是否会遇到格式兼容或转换的问题？

这些疑问背后，正是工具层提供的强大功能和灵活性，使得开发者能够高效地进行游戏开发工作。

### 灵活性

- **工具选择**：工具层允许开发者根据需求选择自己熟悉的开发工具和框架。比如可以选择 **C++** 来进行底层引擎开发，或者选择 **Qt**、**C#**、**WPF**、**Web 前端** 等进行界面或其他相关开发。
- **优势**：这种灵活性使得开发者能够根据自己的工作习惯和项目要求，选择最合适的开发环境，提高开发效率。

### 关卡编辑与协作

- **关卡编辑器**：工具层通常包含关卡编辑器，允许开发者和设计师创建、修改游戏场景，调整游戏中的各类物体和交互。
- **团队协作支持**：支持团队多人协作开发，可以实时同步项目文件和数据，避免冲突，提升开发效率。

### 数字内容创建

- **资产管线**：通过资产处理管线（Asset Conditioning Pipeline），外部文件（如模型、纹理、音效等）可以被自动转换为引擎可用的格式。这使得外部工具与引擎的资产流通变得更加高效。
- **格式支持**：支持广泛的通用数据交换格式，如 **FBX**、**USD** 等，保证在不同工具之间的数据交换顺畅，避免了不兼容问题。

---

---

## 2.核心层

核心层是游戏引擎的基础部分，负责最底层的数学计算、内存管理和数据结构封装，确保引擎的高效性与性能。

### 场景引入：在一个开放世界游戏中，如何确保大量数据和物体的管理不影响游戏性能？

你在开发一个开放世界游戏，场景中有成千上万的 NPC、物品、地形、粒子特效等对象需要同时管理和渲染。你的任务是确保这些对象之间的相互作用不造成帧率下降和卡顿现象。你是否考虑过以下问题？

- **如何确保物体位置、旋转、缩放等计算高效？** 游戏中大量涉及向量运算和矩阵变换，尤其是在物理计算和物体动画中，这些运算是否会对性能造成影响？有没有办法减少计算复杂度？
- **如何处理高效的内存管理？** 游戏世界中不仅有成千上万的动态物体，还包含大量的纹理、音效、动画等资源。如果内存管理不当，是否会导致性能瓶颈或崩溃？
- **如何提高数据访问效率？** 在处理海量的游戏数据时，如何设计合适的数据结构，确保数据能够快速被读取和更新，避免因为频繁的内存访问导致性能损失？

这些问题的背后，正是核心层所提供的高效数学处理、内存管理和数据结构封装的关键作用。

### 数学处理

- **优化技术**：游戏引擎中大量的数学运算（如向量计算、矩阵变换）需要高效的处理。使用如 **Carmack 的 `1/sqrt(x)`** 这种数学优化技巧，可以减少计算的复杂度。
- **SIMD（单指令多数据）**：通过 SIMD 指令集，能够在单个 CPU 指令中并行处理多个数据项，极大提高了浮点数计算的效率，特别是在处理大量数据时（如物理模拟和粒子系统）。

### 数据结构封装

- **目的**：引擎通常会封装高效的数据结构以管理游戏世界中的所有对象、资源等。通过合适的数据结构设计，可以避免内存碎片，优化内存访问模式。
- **效果**：提高数据访问的局部性，从而降低缓存未命中的概率，减少性能损失。

### 内存管理策略

为了最大化性能和减少内存开销，核心层采用了以下内存管理策略：

- **数据聚集**：将相关数据存储在内存中的相邻位置，避免内存访问时的跳跃。
- **顺序访问**：尽量使用顺序访问的方式来提高缓存命中率。避免在内存中随意跳跃访问。
- **批量读写**：采用批量读写的方式，减少每次访问内存的次数。这对于处理大量对象的数据尤为重要。

---

## 3.平台层

平台层主要负责处理与硬件和操作系统的交互，确保引擎在不同平台上的运行一致性。

### 场景引入：如何在多平台环境下保持游戏引擎的一致性和优化？

假设你正在开发一款大型游戏，并且计划将其发布在多个平台上，包括 Windows PC、PlayStation 5、Xbox Series X、iOS 和 Android 等。每个平台的硬件特性、操作系统和图形 API 都不同。你希望能够在所有平台上提供一致的体验，同时不希望为每个平台编写和维护大量的底层平台代码。你可能会遇到以下问题：

- **如何确保游戏引擎能够跨平台运行，而不需要每次修改底层代码？** 各个平台有各自特定的图形 API，如 DirectX、OpenGL、Vulkan，以及不同的操作系统接口，如何简化这些差异，以便能够统一开发和维护？
- **如何让游戏在不同硬件上都能最大限度地发挥性能？** 每个平台的硬件性能和图形渲染能力不同，如何通过抽象的方式适配不同硬件，使得引擎能够根据平台的特点自动进行优化？

- **如何避免重复工作和平台依赖性？** 为了保证开发效率，你不希望在每个平台上都重复做相同的工作。是否可以通过一种方式，让开发者只需关注游戏逻辑和功能，而不必担心底层平台的具体实现？

这些问题的背后，正是 平台层 和 RHI（Render Hardware Interface） 的重要作用。平台层通过提供跨平台设计和统一接口，隐藏了操作系统和硬件之间的差异，而 RHI 则通过抽象图形 API 的实现，确保在不同的硬件和平台上都能获得一致的图形渲染效果和性能。

### 平台无关性

- **跨平台设计**：为了使引擎能在多个平台（如 Windows、Linux、MacOS、Console、Mobile 等）上运行，平台层封装了与平台特定的操作系统和硬件相关的差异。
- **统一接口**：通过提供统一的接口，隐藏了平台之间的差异，开发者无需关心底层平台的实现细节，从而简化开发流程。

### RHI（Render Hardware Interface）

- **定义与作用**：RHI 是一个抽象层，它封装了不同图形硬件和图形 API 之间的差异（如 DirectX、OpenGL、Vulkan 等）。
- **目的**：通过重新定义图形 API 的接口，提供一个平台无关的接口，使得引擎可以适应不同硬件的特性，无需对每种硬件进行专门优化。

## 4.层级结构

在引擎架构中，层级结构的设计对于系统的稳定性和可扩展性至关重要。

### 场景引入：如何确保游戏引擎的稳定性和灵活性之间的平衡？

假设你正在开发一款需要长期维护和迭代的大型游戏。引擎的开发团队在设计引擎架构时，面临一个重要的问题：如何在不牺牲灵活性的前提下，保证底层系统的稳定性？这是一个相当具有挑战性的问题，因为游戏引擎需要既能够支持灵活的功能扩展，又要确保底层架构足够稳定，以应对长期的开发和多平台发布需求。

具体来说，你可能会遇到以下疑问：

- **如果修改底层系统来增加新的功能或优化性能，会不会影响到上层的功能？** 比如，修改图形渲染或物理引擎时，是否会导致游戏逻辑层出现不必要的 bug 或者性能瓶颈？

- **如何在不频繁调整底层代码的情况下，保证上层开发者的灵活性？** 例如，游戏设计师或工具开发者希望快速实现新的功能或修改现有功能，但又不想因为这些修改而影响到引擎底层的稳定性。

- **如何保证引擎在长期迭代和更新中，能够保持一个清晰且可维护的架构？** 引擎团队需要平衡稳定性与灵活性，在保持高效开发的同时，避免因为过多的调整底层代码而导致系统崩溃或难以扩展。

这些问题的核心在于，如何在引擎架构中实现核心层与平台层的稳定性，同时又能够让更高层的功能保持一定的灵活性，以适应不断变化的需求。接下来，我们将探讨通过分层架构和接口设计来解决这一难题。

### 核心层和平台层的稳定性

- **不可随意修改**：核心层和平台层作为引擎的底层部分，它们的稳定性和一致性非常重要。一般情况下，这些层级不建议随意修改。
- **上层调用下层接口**：游戏引擎的上层（如工具层、游戏逻辑层等）通过调用底层的接口来实现具体功能。保持底层的稳定性能够有效避免上层功能出现不必要的故障。

### 上下层的独立性

- **设计原则**：通过分层架构，各层之间尽量减少直接依赖，降低耦合度。这样即使某一层发生变化，也能最小化对其他层的影响。
- **灵活性与稳定性平衡**：虽然上层可以灵活修改和扩展，但底层必须保持稳定，避免频繁修改底层代码导致的不必要的系统崩溃或性能下降。

---

[back](https://fenglimg.github.io/skills-github-pages/2024/11/03/Games104-Notes.html)
