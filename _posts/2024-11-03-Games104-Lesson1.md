---
title: "Lesson1"
date: 2024-11-03
layout: default
---

# Lesson 1 引擎架构分层

## 1. 工具层 (Tool Layer)

- 提供可视化界面，帮助开发者进行编辑和管理。

## 2. 功能层 (Function Layer)

- 包含渲染、动画、脚本和状态机等核心功能模块。

## 3. 资源层 (Resource Layer)

- 负责资源管理，处理游戏中的各种资产（如模型、纹理、音频等）。

## 4. 核心层 (Core Layer)

- 提供基础设施，包括容器管理、垃圾回收、数学库和线程池等。

## 5. 平台层 (Platform Layer)

- 处理与不同平台的交互和输入设备的管理。

## 6. 第三方中间件集成

- 在前五层之上集成第三方中间件，以增强引擎的功能和灵活性。

---

# 引擎中的动画处理

## 7. 格式转换

- 将外部格式转换为资产（asset），例如将贴图转换为 DDS 格式。
- 这一过程应专注于提取有效信息，忽略生成工具的具体细节（类比于将 Word 文档转换为 TXT 格式）。

## 8. 关联文件

- 使用文件（如 XML 或 JSON）来关联网格、纹理、动画等资产。
- 每个资产都应拥有一个特定的 UUID，以确保唯一性和可追踪性。

---

# Tick 函数设计

## 9. Tick 函数

- **`tickLogic`**：处理游戏逻辑的更新。
- **`tickRender`**：负责渲染场景。

## 10. 更新顺序

- 首先进行世界模拟（`tickLogic`），然后再进行渲染（`tickRender`）。
- 这样可以确保渲染出的内容与最新的游戏状态相一致。

## 11. 多线程支持

- 基础的多线程设计将 `tickLogic` 和 `tickRender` 分配到不同的线程中，以提高性能和响应速度。

---

# 实时应用游戏引擎设计

## 12. 核心层

- **数学处理**：使用如 Carmack 的 `1/sqrt(x)` 及 SIMD（单指令多数据）优化数学运算。
- **数据结构封装**：引擎封装数据结构的原因在于消除内存碎片并提高数据访问效率。
- **内存管理策略**：
  - 将相关数据放在一起。
  - 采用顺序访问以提高缓存效率。
  - 实现批量读写，以减少内存访问次数。

## 13. 平台层

- **平台无关性**：掩盖不同平台之间的差异，确保引擎在各个平台上的一致性。
- **RHI（Render Hardware Interface）**：重新定义一层图形 API，封装不同硬件 SDK 的差异，提供统一的接口。

## 14. 工具层

- **灵活性**：允许开发者根据个人喜好选择工具，例如 C++、Qt、C#、WPF 或 Web 前端。
- **关卡编辑与协作**：支持关卡编辑和团队协作功能。
- **数字内容创建**：通过资产处理管线（Asset Conditioning Pipeline）将外部文件转换为资产。
- **通用数据交换格式**：使用 FBX、USD 等格式，确保不同工具间的数据通信顺畅。

## 15. 层级结构

- 越往底层的部分（核心层和平台层）越不建议进行修改，上层调用下层接口，以保持系统的稳定性和一致性。

[back](https://fenglimg.github.io/skills-github-pages/2024/11/03/Games104-Notes.html)
