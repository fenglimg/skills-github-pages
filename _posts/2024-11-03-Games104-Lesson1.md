---
title: "Lesson1"
date: 2024-11-03
layout: default
---

# 游戏引擎架构分层

游戏引擎架构通常采用分层设计，以便于开发、管理和扩展。以下是常见的游戏引擎分层结构说明，每一层都承担着不同的责任，确保引擎的高效和灵活性。

---

## 1. 工具层 (Tool Layer)

**功能**：  
工具层主要是为开发者提供可视化的编辑界面和辅助工具，帮助他们在开发过程中进行资源的管理、场景的编辑、代码调试等工作。这个层次包括：

- **场景编辑器**：开发者用来创建和编辑游戏场景的可视化工具。
- **资源管理器**：用于组织和管理游戏中的所有资源（如模型、纹理、音效等）。
- **脚本调试器和日志系统**：提供实时调试和日志查看，帮助开发者发现问题。
- **动画编辑器、UI 编辑器**：用于创建和调试游戏内动画及界面元素。

**目标**：提供一个易于使用、直观的环境，帮助开发者提高工作效率。

---

## 2. 功能层 (Function Layer)

**功能**：  
功能层包含了游戏引擎的核心功能模块，负责实现游戏的运行机制。这一层主要包括：

- **渲染系统**：负责游戏中的图形渲染，包括 2D/3D 绘制、光照、阴影、特效等。
- **物理引擎**：模拟真实世界的物理现象，如碰撞检测、重力、刚体动力学等。
- **动画系统**：处理游戏中的角色和物体动画，包括骨骼动画、面部表情动画等。
- **脚本系统**：通过脚本语言（如 Lua、Python 等）编写游戏逻辑，实现游戏行为控制。
- **状态机**：用于管理游戏对象的不同状态及其状态之间的转变（例如，角色从“走”状态转为“跳跃”状态）。

**目标**：提供游戏运行所需的核心功能，支撑游戏的交互、表现和行为逻辑。

---

## 3. 资源层 (Resource Layer)

**功能**：  
资源层负责管理和加载游戏的各种资源，它对游戏运行时性能至关重要。包括：

- **资源加载管理**：负责从磁盘或网络加载模型、纹理、音频、动画等资源。
- **内存管理**：高效地管理资源在内存中的存储和卸载，避免内存泄漏或过度消耗。
- **资源压缩与优化**：在游戏中使用的资源通常需要进行压缩或格式转换，以减少内存占用和提高加载速度。
- **资源格式支持**：支持多种文件格式（如.obj、.fbx、.png 等），确保资源能够在引擎中顺利使用。

**目标**：确保资源能够高效加载、存储和管理，支持游戏的流畅运行。

---

## 4. 核心层 (Core Layer)

**功能**：  
核心层提供了游戏引擎的基础设施，负责处理各种底层的操作，包括：

- **容器管理**：管理各种数据结构（如队列、栈、数组等）和对象池，优化内存使用。
- **垃圾回收**：管理内存中的对象生命周期，避免内存泄漏和不必要的内存分配。
- **数学库**：提供向量、矩阵、旋转、变换等数学运算，支撑图形学和物理模拟。
- **线程池与并发**：管理引擎中的多线程任务，优化多核 CPU 的性能，避免线程竞争和死锁。

**目标**：提供高效、稳定的底层服务，支持引擎其他层次的工作。

---

## 5. 平台层 (Platform Layer)

**功能**：  
平台层负责引擎与具体平台的交互，包括硬件、操作系统、输入设备等。具体内容有：

- **平台抽象**：为不同操作系统（如 Windows、macOS、Linux）提供统一接口，确保引擎能在多个平台上运行。
- **输入管理**：处理用户输入，包括鼠标、键盘、手柄、触摸屏等设备。
- **文件系统**：为游戏提供平台无关的文件操作接口。
- **网络支持**：处理网络通信，支持多人游戏和网络功能。

**目标**：确保引擎能够跨平台运行，并正确处理各种硬件和操作系统的差异。

---

## 6. 第三方中间件集成 (Third-Party Middleware Integration)

**功能**：  
这一层是为了增强引擎的功能，集成各种第三方中间件和库。例如：

- **音频中间件**（如 FMOD、Wwise）：提供音效处理、3D 音频定位等高级音频功能。
- **AI 中间件**（如 Recast、NavMesh）：用于实现游戏中的导航网格、路径寻路等 AI 相关功能。
- **物理引擎中间件**（如 Havok、PhysX）：提供更高效、精准的物理模拟。
- **视频渲染库**（如 OpenGL、Vulkan、DirectX）：提供底层图形 API 支持，增强图形渲染性能和效果。

**目标**：通过集成各种成熟的中间件，避免重复造轮子，并快速提升引擎的功能和性能。

---

# 引擎中的动画处理

在游戏引擎中，动画处理涉及多个环节，包括格式转换、文件关联、资源管理等。以下是这两个方面的详细说明。

---

## 7. 格式转换

**功能说明**：  
格式转换是指将外部资源文件转换为游戏引擎能够识别并高效加载的格式。例如，将图像文件（如 PNG、JPEG）转换为更适合游戏渲染的格式（如 DDS 格式），或者将模型文件从 FBX 转换为引擎支持的自定义格式。

**关键目标**：

- **优化资源存储**：转换后的文件通常会经过压缩或其他处理，减小存储空间，提升加载效率。
- **统一资源标准**：确保所有资源都符合引擎的格式要求，以便统一处理和管理。

**例子**：

- 将贴图（如 PNG、JPEG 格式）转换为更适合图形处理的 DDS 格式。
- 将 3D 模型（如 FBX 格式）转换为引擎支持的自定义模型格式。

**注意事项**：

- 转换过程中要专注于提取有效的资源数据，忽略生成工具的具体细节。  
  例如，将一个 Word 文档转换为纯文本文件时，文件中的格式信息（如字体、颜色等）通常会被丢弃，只保留文本内容。

---

## 8. 关联文件

**功能说明**：  
关联文件用于在不同资源之间建立联系，以便引擎能够准确地加载并组合它们。例如，场景中的一个 3D 模型可能需要关联特定的纹理、动画和材质等。通过关联文件，可以简化资源的管理，并确保资源在加载时能够正确配合使用。

**关键目标**：

- **简化资源管理**：通过关联文件（如 XML、JSON 等格式），开发者能够清晰地查看和修改资源之间的关系。
- **提高资源加载效率**：引擎可以在加载时通过关联文件快速找到需要的资源，避免不必要的搜索和加载。

**常见格式**：

- **XML**：一种常见的标记语言，适用于描述复杂的资源结构。
- **JSON**：一种轻量级的数据交换格式，易于人类阅读和编写，也方便机器解析和生成。

**UUID 唯一标识符**：

- 为了确保每个资源的唯一性和可追踪性，每个资产（如纹理、模型、动画等）都会分配一个独特的 **UUID**（通用唯一标识符）。这确保了在复杂项目中，资源不会被重复或错误引用。

**例子**：

- 一个包含 3D 模型的 XML 文件可能如下所示：

  ```xml
  <asset>
      <uuid>123e4567-e89b-12d3-a456-426614174000</uuid>
      <type>model</type>
      <path>assets/models/character.obj</path>
      <textures>
          <texture uuid="987e6543-e89b-12d3-a456-426614174111" path="assets/textures/character_diffuse.dds"/>
          <texture uuid="987e6543-e89b-12d3-a456-426614174112" path="assets/textures/character_normal.dds"/>
      </textures>
  </asset>
  ```

# Tick 函数设计

在游戏引擎中，`Tick` 函数通常用于在每一帧更新时进行游戏逻辑处理与渲染。它分为多个子函数或阶段，以确保游戏的流畅执行和高效渲染。

---

## 9. Tick 函数的主要组成

### `tickLogic` — 处理游戏逻辑更新

- **功能**：`tickLogic` 函数负责更新游戏中的逻辑内容，如角色移动、碰撞检测、AI 行为、物理模拟等。
- **执行时机**：它在每一帧的开始部分执行，确保游戏状态能够根据玩家输入、时间流逝等因素进行更新。
- **重点**：逻辑更新通常不会直接依赖渲染输出，而是根据当前的游戏状态执行相关计算。

### `tickRender` — 负责渲染场景

- **功能**：`tickRender` 函数负责渲染所有游戏场景，包括对象、角色、环境、UI 元素等。它通常会使用由 `tickLogic` 更新后的数据（如角色位置、状态等）来绘制最终图像。
- **执行时机**：`tickRender` 在每一帧的后期执行，确保场景的视觉效果能够展现最新的游戏状态。
- **重点**：渲染过程一般依赖于图形硬件，涉及大量计算，可能会影响帧率。

---

## 10. 更新顺序

- 游戏引擎的典型更新顺序是：**首先执行游戏逻辑更新（`tickLogic`），然后执行渲染（`tickRender`）**。
- **原因**：这样设计的目的是确保渲染出的内容与最新的游戏状态一致。例如，玩家移动或物体碰撞后，场景应该即时反映这些变化，而不是显示上一帧的数据。

### 举例说明：

假设有一个简单的场景，其中玩家控制一个角色。如果逻辑更新（`tickLogic`）在渲染之前执行，玩家的移动位置、状态变化等将在渲染时准确展示出来，避免出现角色停留在上一个位置或没有更新的画面。

---

## 11. 多线程支持

为了提高性能和响应速度，特别是在复杂场景中，`tickLogic` 和 `tickRender` 可以分配到不同的线程中并行执行。

### 设计目标：

- **分离计算和渲染**：将游戏逻辑和渲染操作分离到独立的线程中，可以让游戏引擎同时进行计算和渲染，从而提高帧率和响应速度。
- **减少瓶颈**：渲染通常是一个耗时的操作，若与游戏逻辑在同一线程中执行，可能会导致性能瓶颈。通过多线程设计，能够在不同核心上并行处理游戏逻辑和渲染任务。

### 关键注意事项：

- **线程同步**：多线程设计需要确保线程间的数据同步，避免数据冲突或错误。例如，`tickRender` 需要访问由 `tickLogic` 更新的状态，若没有适当的同步机制，可能会出现渲染不一致的情况。
- **资源管理**：多线程会增加对资源的竞争，尤其是在渲染和逻辑更新同时发生时。因此，需要仔细管理内存和数据访问。

### 举例说明：

假设游戏中有多个 NPC 和物体需要模拟其行为。如果 `tickLogic` 在一个线程中更新这些 NPC 的位置和状态，而 `tickRender` 在另一个线程中渲染场景，两个线程可以并行工作，从而提高整个引擎的运行效率。

---

# 实时应用游戏引擎设计

游戏引擎的设计涉及多个层级，每一层都有其特定的功能和责任，下面是对引擎设计各层级的详细说明。

---

## 12. 核心层

核心层是游戏引擎的基础部分，负责最底层的数学计算、内存管理和数据结构封装，确保引擎的高效性与性能。

### 12.1 数学处理

- **优化技术**：游戏引擎中大量的数学运算（如向量计算、矩阵变换）需要高效的处理。使用如 **Carmack 的 `1/sqrt(x)`** 这种数学优化技巧，可以减少计算的复杂度。
- **SIMD（单指令多数据）**：通过 SIMD 指令集，能够在单个 CPU 指令中并行处理多个数据项，极大提高了浮点数计算的效率，特别是在处理大量数据时（如物理模拟和粒子系统）。

### 12.2 数据结构封装

- **目的**：引擎通常会封装高效的数据结构以管理游戏世界中的所有对象、资源等。通过合适的数据结构设计，可以避免内存碎片，优化内存访问模式。
- **效果**：提高数据访问的局部性，从而降低缓存未命中的概率，减少性能损失。

### 12.3 内存管理策略

为了最大化性能和减少内存开销，核心层采用了以下内存管理策略：

- **数据聚集**：将相关数据存储在内存中的相邻位置，避免内存访问时的跳跃。
- **顺序访问**：尽量使用顺序访问的方式来提高缓存命中率。避免在内存中随意跳跃访问。
- **批量读写**：采用批量读写的方式，减少每次访问内存的次数。这对于处理大量对象的数据尤为重要。

---

## 13. 平台层

平台层主要负责处理与硬件和操作系统的交互，确保引擎在不同平台上的运行一致性。

### 13.1 平台无关性

- **跨平台设计**：为了使引擎能在多个平台（如 Windows、Linux、MacOS、Console、Mobile 等）上运行，平台层封装了与平台特定的操作系统和硬件相关的差异。
- **统一接口**：通过提供统一的接口，隐藏了平台之间的差异，开发者无需关心底层平台的实现细节，从而简化开发流程。

### 13.2 RHI（Render Hardware Interface）

- **定义与作用**：RHI 是一个抽象层，它封装了不同图形硬件和图形 API 之间的差异（如 DirectX、OpenGL、Vulkan 等）。
- **目的**：通过重新定义图形 API 的接口，提供一个平台无关的接口，使得引擎可以适应不同硬件的特性，无需对每种硬件进行专门优化。

---

## 14. 工具层

工具层为开发者提供了可定制的工作环境，支持多种开发工具和资产处理管线。

### 14.1 灵活性

- **工具选择**：工具层允许开发者根据需求选择自己熟悉的开发工具和框架。比如可以选择 **C++** 来进行底层引擎开发，或者选择 **Qt**、**C#**、**WPF**、**Web 前端** 等进行界面或其他相关开发。
- **优势**：这种灵活性使得开发者能够根据自己的工作习惯和项目要求，选择最合适的开发环境，提高开发效率。

### 14.2 关卡编辑与协作

- **关卡编辑器**：工具层通常包含关卡编辑器，允许开发者和设计师创建、修改游戏场景，调整游戏中的各类物体和交互。
- **团队协作支持**：支持团队多人协作开发，可以实时同步项目文件和数据，避免冲突，提升开发效率。

### 14.3 数字内容创建

- **资产管线**：通过资产处理管线（Asset Conditioning Pipeline），外部文件（如模型、纹理、音效等）可以被自动转换为引擎可用的格式。这使得外部工具与引擎的资产流通变得更加高效。
- **格式支持**：支持广泛的通用数据交换格式，如 **FBX**、**USD** 等，保证在不同工具之间的数据交换顺畅，避免了不兼容问题。

---

## 15. 层级结构

在引擎架构中，层级结构的设计对于系统的稳定性和可扩展性至关重要。

### 15.1 核心层和平台层的稳定性

- **不可随意修改**：核心层和平台层作为引擎的底层部分，它们的稳定性和一致性非常重要。一般情况下，这些层级不建议随意修改。
- **上层调用下层接口**：游戏引擎的上层（如工具层、游戏逻辑层等）通过调用底层的接口来实现具体功能。保持底层的稳定性能够有效避免上层功能出现不必要的故障。

### 15.2 上下层的独立性

- **设计原则**：通过分层架构，各层之间尽量减少直接依赖，降低耦合度。这样即使某一层发生变化，也能最小化对其他层的影响。
- **灵活性与稳定性平衡**：虽然上层可以灵活修改和扩展，但底层必须保持稳定，避免频繁修改底层代码导致的不必要的系统崩溃或性能下降。

---

[back](https://fenglimg.github.io/skills-github-pages/2024/11/03/Games104-Notes.html)
